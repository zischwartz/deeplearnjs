import '../ndarray-image-visualizer';
import '../ndarray-logits-visualizer';
import './model-layer';
import '../demo-header';
import '../demo-footer';
import { FeedEntry, NDArray, Scalar } from '../deeplearn';
import { PolymerHTMLElement } from '../polymer-spec';
import { ModelLayer } from './model-layer';
export declare let ModelBuilderPolymer: new () => PolymerHTMLElement;
export declare enum ApplicationState {
    IDLE = 1,
    TRAINING = 2,
}
export declare class ModelBuilder extends ModelBuilderPolymer {
    private isValid;
    private totalTimeSec;
    private applicationState;
    private modelInitialized;
    private showTrainStats;
    private selectedNormalizationOption;
    private graphRunner;
    private graph;
    private session;
    private optimizer;
    private xTensor;
    private labelTensor;
    private costTensor;
    private accuracyTensor;
    private predictionTensor;
    private datasetDownloaded;
    private datasetNames;
    private selectedDatasetName;
    private modelNames;
    private selectedModelName;
    private optimizerNames;
    private selectedOptimizerName;
    private loadedWeights;
    private dataSets;
    private dataSet;
    private xhrDatasetConfigs;
    private datasetStats;
    private learningRate;
    private momentum;
    private needMomentum;
    private gamma;
    private needGamma;
    private beta1;
    private needBeta1;
    private beta2;
    private needBeta2;
    private batchSize;
    private showDatasetStats;
    private statsInputRange;
    private statsInputShapeDisplay;
    private statsLabelShapeDisplay;
    private statsExampleCount;
    private costChart;
    private accuracyChart;
    private examplesPerSecChart;
    private costChartData;
    private accuracyChartData;
    private examplesPerSecChartData;
    private trainButton;
    private inputNDArrayVisualizers;
    private outputNDArrayVisualizers;
    private inputShape;
    private labelShape;
    private examplesPerSec;
    private examplesTrained;
    private inferencesPerSec;
    private inferenceDuration;
    private inputLayer;
    private hiddenLayers;
    private layersContainer;
    private math;
    private mathGPU;
    private mathCPU;
    ready(): void;
    isTraining(applicationState: ApplicationState): boolean;
    isIdle(applicationState: ApplicationState): boolean;
    private getTestData();
    private getTrainingData();
    private startInference();
    private resetHyperParamRequirements();
    private refreshHyperParamRequirements(optimizerName);
    private createOptimizer();
    private startTraining();
    private createModel();
    private populateDatasets();
    private updateSelectedDataset(datasetName);
    private populateModelDropdown();
    private updateSelectedModel(modelName);
    private loadModelFromPath(modelPath);
    private setupDatasetStats();
    private applyNormalization(selectedNormalizationOption);
    private recreateCharts();
    private createChart(canvasId, label, data, min?, max?);
    displayBatchesTrained(totalBatchesTrained: number): void;
    displayCost(avgCost: Scalar): void;
    displayAccuracy(accuracy: Scalar): void;
    displayInferenceExamplesPerSec(examplesPerSec: number): void;
    displayExamplesPerSec(examplesPerSec: number): void;
    private smoothExamplesPerSec(lastExamplesPerSec, nextExamplesPerSec);
    displayInferenceExamplesOutput(inputFeeds: FeedEntry[][], inferenceOutputs: NDArray[]): void;
    addLayer(): ModelLayer;
    removeLayer(modelLayer: ModelLayer): void;
    private removeAllLayers();
    private validateModel();
    layerParamChanged(): void;
    private downloadModel();
    private uploadModel();
    private setupUploadModelButton();
    private getModelAsJson();
    private loadModelFromJson(modelJson);
    private uploadWeights();
    private setupUploadWeightsButton();
    private loadWeightsFromJson(weightsJson);
}
